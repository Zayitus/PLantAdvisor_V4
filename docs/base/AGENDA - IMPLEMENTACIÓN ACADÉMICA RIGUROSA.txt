"""
AGENDA - IMPLEMENTACIÃ“N ACADÃ‰MICA RIGUROSA
==========================================

FUNDAMENTO TEÃ“RICO (Clase 3 - Figura 6):
"Agenda: Mantiene una lista de reglas activadas para ser ejecutadas por el 
mecanismo de inferencia"

REFERENCIA ACADÃ‰MICA: 
- Giarratano & Riley - "Expert Systems: Principles and Programming"
- Clase 3 - "El ciclo de ejecuciÃ³n de un sistema experto implica resolver conflictos"

COMPONENTES ACADÃ‰MICOS IMPLEMENTADOS:
1. GestiÃ³n de reglas activadas/instanciadas
2. Estrategias de conflict resolution acadÃ©micas
3. Control de ejecuciÃ³n de reglas
4. PriorizaciÃ³n basada en criterios acadÃ©micos
5. Soporte para explicaciÃ³n del conflict resolution

ARQUITECTURA: Basada en sistemas clÃ¡sicos MYCIN/DENDRAL
"""

from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import copy


class EstrategiaConflictResolution(Enum):
    """
    ESTRATEGIAS ACADÃ‰MICAS DE CONFLICT RESOLUTION
    
    FUNDAMENTO TEÃ“RICO: En sistemas expertos clÃ¡sicos existen mÃºltiples 
    estrategias para resolver conflictos cuando varias reglas estÃ¡n activadas.
    
    REFERENCIA: Clase 3 - "resolver conflictos (decidir quÃ© regla aplicar si hay varias activadas)"
    """
    ESPECIFICIDAD = "especificidad"       # Reglas mÃ¡s especÃ­ficas tienen prioridad
    RECENCIA = "recencia"                 # Hechos mÃ¡s recientes tienen prioridad  
    COMPLEJIDAD = "complejidad"           # Reglas mÃ¡s complejas tienen prioridad
    PRIORIDAD_EXPLICITA = "prioridad"     # Prioridad asignada explÃ­citamente
    ORDEN_REGLA = "orden"                 # Orden de definiciÃ³n de reglas


@dataclass
class ReglaInstanciada:
    """
    REPRESENTACIÃ“N ACADÃ‰MICA DE UNA REGLA ACTIVADA/INSTANCIADA
    
    FUNDAMENTO TEÃ“RICO: Cuando las condiciones de una regla se satisfacen con 
    hechos especÃ­ficos en memoria, se crea una "instancia" de la regla.
    
    COMPONENTES ACADÃ‰MICOS:
    - Referencia a la regla original
    - Bindings especÃ­ficos de variables
    - Timestamp de activaciÃ³n
    - MÃ©tricas para conflict resolution
    """
    regla_id: str                         # ID de la regla original
    bindings: Dict[str, Any]              # Variables unificadas con valores especÃ­ficos
    hechos_activadores: List[str]         # IDs de hechos que activaron esta regla
    timestamp_activacion: datetime = field(default_factory=datetime.now)
    especificidad: int = 0                # NÃºmero de condiciones satisfechas
    complejidad: int = 0                  # Complejidad computacional de la regla
    prioridad_explicita: float = 0.0      # Prioridad asignada por diseÃ±ador
    orden_definicion: int = 0             # Orden en que fue definida la regla
    justificacion_activacion: str = ""    # Por quÃ© se activÃ³ esta regla
    ya_ejecutada: bool = False            # Flag para evitar re-ejecuciÃ³n


class Agenda:
    """
    AGENDA ACADÃ‰MICA - GESTIÃ“N DE REGLAS ACTIVADAS
    
    FUNDAMENTO TEÃ“RICO (Clase 3):
    "Agenda: Mantiene una lista de reglas activadas para ser ejecutadas por el 
    mecanismo de inferencia"
    
    RESPONSABILIDADES ACADÃ‰MICAS:
    1. Mantener lista de reglas instanciadas (activadas)
    2. Aplicar estrategias de conflict resolution
    3. Seleccionar prÃ³xima regla a ejecutar
    4. Prevenir re-ejecuciÃ³n de reglas ya procesadas
    5. Generar explicaciÃ³n del proceso de selecciÃ³n
    
    REFERENCIA: Arquitectura basada en MYCIN (Stanford, 1972)
    """
    
    def __init__(self, estrategia: EstrategiaConflictResolution = EstrategiaConflictResolution.ESPECIFICIDAD):
        """
        INICIALIZACIÃ“N DE AGENDA ACADÃ‰MICA
        
        Args:
            estrategia: Estrategia de conflict resolution a utilizar
        """
        # LISTA DE REGLAS ACTIVADAS/INSTANCIADAS
        self._reglas_instanciadas: List[ReglaInstanciada] = []
        
        # ESTRATEGIA DE CONFLICT RESOLUTION
        self._estrategia = estrategia
        
        # HISTORIAL DE REGLAS EJECUTADAS
        self._historial_ejecucion: List[ReglaInstanciada] = []
        
        # CONTADOR PARA ORDEN DE ACTIVACIÃ“N
        self._contador_activacion = 0
        
        # REGISTRO DE CONFLICT RESOLUTION PARA EXPLICACIÃ“N
        self._trace_conflict_resolution: List[Dict[str, Any]] = []
        
        print("ðŸ“‹ AGENDA ACADÃ‰MICA INICIALIZADA")
        print(f"ðŸŽ¯ Estrategia de Conflict Resolution: {estrategia.value}")
        print("ðŸ›ï¸ ImplementaciÃ³n basada en sistemas expertos clÃ¡sicos")
    
    def activar_regla(self, regla_id: str, bindings: Dict[str, Any], 
                     hechos_activadores: List[str], especificidad: int = 0,
                     complejidad: int = 0, prioridad_explicita: float = 0.0,
                     justificacion: str = "") -> str:
        """
        ACTIVAR REGLA E INSERTAR EN AGENDA
        
        FUNDAMENTO ACADÃ‰MICO: Cuando el pattern matching encuentra que las 
        condiciones de una regla se satisfacen, la regla se "activa" e 
        ingresa a la agenda.
        
        Args:
            regla_id: Identificador de la regla
            bindings: Variables unificadas con valores
            hechos_activadores: Hechos que causaron la activaciÃ³n
            especificidad: NÃºmero de condiciones satisfechas
            complejidad: Complejidad de la regla
            prioridad_explicita: Prioridad asignada explÃ­citamente
            justificacion: ExplicaciÃ³n de por quÃ© se activÃ³
            
        Returns:
            str: ID Ãºnico de la instancia activada
            
        REFERENCIA: Clase 3 - Ciclo Match-Conflict Resolution-Act
        """
        self._contador_activacion += 1
        
        # Verificar si ya existe una instancia idÃ©ntica
        if self._existe_instancia_identica(regla_id, bindings):
            print(f"âš ï¸  REGLA YA INSTANCIADA: {regla_id} con bindings idÃ©nticos")
            return ""
        
        regla_instanciada = ReglaInstanciada(
            regla_id=regla_id,
            bindings=copy.deepcopy(bindings),
            hechos_activadores=hechos_activadores.copy(),
            especificidad=especificidad,
            complejidad=complejidad,
            prioridad_explicita=prioridad_explicita,
            orden_definicion=self._contador_activacion,
            justificacion_activacion=justificacion or f"Activada por hechos: {hechos_activadores}"
        )
        
        self._reglas_instanciadas.append(regla_instanciada)
        
        print(f"âš¡ REGLA ACTIVADA: {regla_id}")
        print(f"   ðŸ“Š Especificidad: {especificidad}, Complejidad: {complejidad}")
        print(f"   ðŸ”— Hechos activadores: {hechos_activadores}")
        
        return f"{regla_id}_{self._contador_activacion}"
    
    def seleccionar_proxima_regla(self) -> Optional[ReglaInstanciada]:
        """
        SELECCIONAR PRÃ“XIMA REGLA PARA EJECUCIÃ“N (CONFLICT RESOLUTION)
        
        FUNDAMENTO ACADÃ‰MICO: "El ciclo de ejecuciÃ³n de un sistema experto 
        implica resolver conflictos (decidir quÃ© regla aplicar si hay varias activadas)"
        
        Implementa estrategias acadÃ©micas de conflict resolution segÃºn la 
        literatura clÃ¡sica de sistemas expertos.
        
        Returns:
            ReglaInstanciada: Regla seleccionada para ejecutar, o None si agenda vacÃ­a
            
        REFERENCIA: Clase 3 - Conflict Resolution
        """
        # Filtrar reglas no ejecutadas
        reglas_pendientes = [r for r in self._reglas_instanciadas if not r.ya_ejecutada]
        
        if not reglas_pendientes:
            print("ðŸ“­ AGENDA VACÃA: No hay reglas pendientes de ejecuciÃ³n")
            return None
        
        print(f"\nðŸ”€ CONFLICT RESOLUTION ({self._estrategia.value})")
        print(f"   ðŸ“Š Candidatos: {len(reglas_pendientes)} reglas")
        
        # Aplicar estrategia de conflict resolution
        regla_seleccionada = self._aplicar_estrategia_conflict_resolution(reglas_pendientes)
        
        if regla_seleccionada:
            # Registrar en trace para explicaciÃ³n
            self._registrar_conflict_resolution(reglas_pendientes, regla_seleccionada)
            
            print(f"âœ… REGLA SELECCIONADA: {regla_seleccionada.regla_id}")
            print(f"   ðŸŽ¯ RazÃ³n: {self._explicar_seleccion(regla_seleccionada)}")
        
        return regla_seleccionada
    
    def marcar_como_ejecutada(self, regla_instanciada: ReglaInstanciada):
        """
        MARCAR REGLA COMO EJECUTADA
        
        FUNDAMENTO ACADÃ‰MICO: Para prevenir re-ejecuciÃ³n de reglas ya procesadas
        y mantener control del ciclo de inferencia.
        """
        regla_instanciada.ya_ejecutada = True
        self._historial_ejecucion.append(regla_instanciada)
        
        print(f"âœ… REGLA EJECUTADA: {regla_instanciada.regla_id}")
    
    def obtener_reglas_pendientes(self) -> List[ReglaInstanciada]:
        """OBTENER REGLAS PENDIENTES DE EJECUCIÃ“N"""
        return [r for r in self._reglas_instanciadas if not r.ya_ejecutada]
    
    def obtener_historial_ejecucion(self) -> List[ReglaInstanciada]:
        """OBTENER HISTORIAL DE REGLAS EJECUTADAS"""
        return self._historial_ejecucion.copy()
    
    def esta_vacia(self) -> bool:
        """VERIFICAR SI AGENDA ESTÃ VACÃA (no hay reglas pendientes)"""
        return len(self.obtener_reglas_pendientes()) == 0
    
    def limpiar_agenda(self):
        """
        LIMPIAR AGENDA PARA NUEVA CONSULTA
        
        FUNDAMENTO ACADÃ‰MICO: Entre consultas, la agenda debe reinicializarse
        para evitar interferencia entre sesiones de razonamiento.
        """
        self._reglas_instanciadas.clear()
        self._historial_ejecucion.clear()
        self._trace_conflict_resolution.clear()
        self._contador_activacion = 0
        
        print("ðŸ§¹ AGENDA LIMPIADA")
    
    def generar_trace_conflict_resolution(self) -> Dict[str, Any]:
        """
        GENERAR TRACE DE CONFLICT RESOLUTION PARA EXPLICACIÃ“N
        
        FUNDAMENTO ACADÃ‰MICO: Los sistemas expertos deben poder explicar 
        por quÃ© seleccionaron ciertas reglas sobre otras.
        """
        return {
            'estrategia_utilizada': self._estrategia.value,
            'total_activaciones': len(self._reglas_instanciadas),
            'reglas_ejecutadas': len(self._historial_ejecucion),
            'reglas_pendientes': len(self.obtener_reglas_pendientes()),
            'decisiones_conflict_resolution': self._trace_conflict_resolution,
            'historial_ejecucion': [
                {
                    'regla_id': r.regla_id,
                    'timestamp': r.timestamp_activacion.isoformat(),
                    'especificidad': r.especificidad,
                    'justificacion': r.justificacion_activacion
                }
                for r in self._historial_ejecucion
            ]
        }
    
    def _aplicar_estrategia_conflict_resolution(self, candidatos: List[ReglaInstanciada]) -> Optional[ReglaInstanciada]:
        """
        APLICAR ESTRATEGIA ESPECÃFICA DE CONFLICT RESOLUTION
        
        FUNDAMENTO ACADÃ‰MICO: Diferentes estrategias han sido desarrolladas 
        en la literatura para resolver conflictos entre reglas.
        """
        if not candidatos:
            return None
        
        if self._estrategia == EstrategiaConflictResolution.ESPECIFICIDAD:
            # Reglas mÃ¡s especÃ­ficas (mÃ¡s condiciones) tienen prioridad
            return max(candidatos, key=lambda r: r.especificidad)
        
        elif self._estrategia == EstrategiaConflictResolution.RECENCIA:
            # Reglas activadas mÃ¡s recientemente tienen prioridad
            return max(candidatos, key=lambda r: r.timestamp_activacion)
        
        elif self._estrategia == EstrategiaConflictResolution.COMPLEJIDAD:
            # Reglas mÃ¡s complejas tienen prioridad
            return max(candidatos, key=lambda r: r.complejidad)
        
        elif self._estrategia == EstrategiaConflictResolution.PRIORIDAD_EXPLICITA:
            # Prioridad asignada explÃ­citamente por diseÃ±ador
            return max(candidatos, key=lambda r: r.prioridad_explicita)
        
        elif self._estrategia == EstrategiaConflictResolution.ORDEN_REGLA:
            # Orden de definiciÃ³n de reglas (FIFO)
            return min(candidatos, key=lambda r: r.orden_definicion)
        
        else:
            # Default: especificidad
            return max(candidatos, key=lambda r: r.especificidad)
    
    def _existe_instancia_identica(self, regla_id: str, bindings: Dict[str, Any]) -> bool:
        """VERIFICAR SI YA EXISTE INSTANCIA IDÃ‰NTICA (evitar duplicados)"""
        for instancia in self._reglas_instanciadas:
            if instancia.regla_id == regla_id and instancia.bindings == bindings:
                return True
        return False
    
    def _explicar_seleccion(self, regla_seleccionada: ReglaInstanciada) -> str:
        """GENERAR EXPLICACIÃ“N DE POR QUÃ‰ SE SELECCIONÃ“ ESTA REGLA"""
        if self._estrategia == EstrategiaConflictResolution.ESPECIFICIDAD:
            return f"Mayor especificidad ({regla_seleccionada.especificidad} condiciones)"
        elif self._estrategia == EstrategiaConflictResolution.RECENCIA:
            return f"ActivaciÃ³n mÃ¡s reciente ({regla_seleccionada.timestamp_activacion})"
        elif self._estrategia == EstrategiaConflictResolution.COMPLEJIDAD:
            return f"Mayor complejidad ({regla_seleccionada.complejidad})"
        elif self._estrategia == EstrategiaConflictResolution.PRIORIDAD_EXPLICITA:
            return f"Mayor prioridad explÃ­cita ({regla_seleccionada.prioridad_explicita})"
        else:
            return f"Criterio: {self._estrategia.value}"
    
    def _registrar_conflict_resolution(self, candidatos: List[ReglaInstanciada], seleccionada: ReglaInstanciada):
        """REGISTRAR DECISIÃ“N DE CONFLICT RESOLUTION PARA TRACE"""
        decision = {
            'timestamp': datetime.now().isoformat(),
            'estrategia': self._estrategia.value,
            'candidatos': [
                {
                    'regla_id': r.regla_id,
                    'especificidad': r.especificidad,
                    'complejidad': r.complejidad,
                    'prioridad': r.prioridad_explicita
                }
                for r in candidatos
            ],
            'seleccionada': seleccionada.regla_id,
            'razon_seleccion': self._explicar_seleccion(seleccionada)
        }
        
        self._trace_conflict_resolution.append(decision)
    
    def __str__(self) -> str:
        """REPRESENTACIÃ“N TEXTUAL DE LA AGENDA"""
        pendientes = len(self.obtener_reglas_pendientes())
        ejecutadas = len(self._historial_ejecucion)
        return f"Agenda(pendientes={pendientes}, ejecutadas={ejecutadas}, estrategia={self._estrategia.value})"


# ===================================================================
# EJEMPLO DE USO ACADÃ‰MICO
# ===================================================================

if __name__ == "__main__":
    print("ðŸŽ“ TESTING AGENDA ACADÃ‰MICA")
    print("="*50)
    
    # Crear agenda con estrategia de especificidad
    agenda = Agenda(EstrategiaConflictResolution.ESPECIFICIDAD)
    
    # Simular activaciÃ³n de reglas
    agenda.activar_regla(
        regla_id="R001_UBICACION",
        bindings={"planta": "sansevieria", "ubicacion": "interior"},
        hechos_activadores=["F0001", "F0002"],
        especificidad=2,
        complejidad=1,
        justificacion="UbicaciÃ³n compatible"
    )
    
    agenda.activar_regla(
        regla_id="R002_ESPACIO",
        bindings={"planta": "sansevieria", "espacio": "mediano"},
        hechos_activadores=["F0003"],
        especificidad=3,  # Mayor especificidad
        complejidad=2,
        justificacion="Espacio compatible"
    )
    
    # Simular conflict resolution
    print(f"\nðŸ“Š ESTADO AGENDA: {agenda}")
    
    # Seleccionar prÃ³xima regla
    regla = agenda.seleccionar_proxima_regla()
    if regla:
        agenda.marcar_como_ejecutada(regla)
    
    # Generar trace
    trace = agenda.generar_trace_conflict_resolution()
    print(f"\nðŸ“‹ TRACE GENERADO: {len(trace['decisiones_conflict_resolution'])} decisiones")
    
    print("\nâœ… AGENDA ACADÃ‰MICA VALIDADA")