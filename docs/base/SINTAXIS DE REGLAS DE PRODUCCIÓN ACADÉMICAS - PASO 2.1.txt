"""
SINTAXIS DE REGLAS DE PRODUCCI√ìN ACAD√âMICAS - PASO 2.1
=======================================================

FUNDAMENTO TE√ìRICO (Clase 3):
"En estos sistemas, el conocimiento se representa en forma de reglas de 
producci√≥n del tipo 'SI (condici√≥n) ENTONCES (acci√≥n)'"

REFERENCIA ACAD√âMICA:
- Sistemas de Post sobre sistemas de reescritura  
- Algoritmos de Markov y Rete para emparejamiento eficiente de patrones
- Naturaleza modular para mantenimiento y explicaci√≥n

DISE√ëO DE SINTAXIS ACAD√âMICA:
Cada regla debe ser declarativa, modular, explicable y ejecutable din√°micamente
"""

from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass, field
from abc import ABC, abstractmethod
from enum import Enum
import re


class OperadorCondicion(Enum):
    """
    OPERADORES ACAD√âMICOS PARA CONDICIONES DE REGLAS
    
    FUNDAMENTO: Permiten expresar diferentes tipos de relaciones l√≥gicas
    en las condiciones de las reglas de producci√≥n.
    """
    IGUAL = "=="                    # Igualdad exacta
    DIFERENTE = "!="               # Desigualdad  
    MENOR = "<"                    # Menor que
    MENOR_IGUAL = "<="             # Menor o igual
    MAYOR = ">"                    # Mayor que
    MAYOR_IGUAL = ">="             # Mayor o igual
    CONTIENE = "contains"          # Contiene elemento
    EN = "in"                      # Elemento en lista
    NO_EN = "not_in"              # Elemento no en lista
    EXISTE = "exists"              # Hecho existe en memoria
    NO_EXISTE = "not_exists"       # Hecho no existe en memoria
    COINCIDE_PATRON = "matches"    # Coincide con patr√≥n regex


class TipoAccion(Enum):
    """
    TIPOS ACAD√âMICOS DE ACCIONES EN REGLAS
    
    FUNDAMENTO TE√ìRICO: "Despu√©s de la parte ENTONCES de una regla, hay una 
    serie de acciones que se ejecutar√°n cuando la regla se dispare"
    """
    ASSERT = "assert"              # Agregar nuevo hecho a memoria
    RETRACT = "retract"            # Eliminar hecho de memoria
    MODIFY = "modify"              # Modificar hecho existente
    CONCLUDE = "conclude"          # Establecer conclusi√≥n final
    CALL_FUNCTION = "call"         # Ejecutar funci√≥n externa
    SET_VARIABLE = "set"           # Asignar valor a variable
    INCREMENT = "increment"        # Incrementar valor num√©rico
    RECOMMEND = "recommend"        # Recomendar acci√≥n/elemento


@dataclass
class CondicionRegla:
    """
    REPRESENTACI√ìN ACAD√âMICA DE UNA CONDICI√ìN DE REGLA
    
    FUNDAMENTO: Cada condici√≥n debe poder ser evaluada contra la memoria
    de trabajo para determinar si se satisface o no.
    
    ESTRUCTURA CL√ÅSICA: predicado operador valor
    """
    predicado: str                    # Nombre del hecho/predicado
    operador: OperadorCondicion       # Operador de comparaci√≥n
    valor: Any                        # Valor de comparaci√≥n
    variable: Optional[str] = None    # Variable para binding (ej: ?X)
    peso: float = 1.0                # Peso de la condici√≥n
    explicacion: str = ""            # Explicaci√≥n de la condici√≥n
    
    def __str__(self) -> str:
        var_str = f" -> ${self.variable}" if self.variable else ""
        return f"{self.predicado} {self.operador.value} {self.valor}{var_str}"


@dataclass  
class AccionRegla:
    """
    REPRESENTACI√ìN ACAD√âMICA DE UNA ACCI√ìN DE REGLA
    
    FUNDAMENTO: "las acciones espec√≠ficas incluyen la adici√≥n o remoci√≥n 
    de los hechos en la memoria activa"
    """
    tipo: TipoAccion                  # Tipo de acci√≥n a ejecutar
    predicado: str                    # Predicado objetivo
    valor: Any = None                 # Valor a asignar/usar
    parametros: Dict[str, Any] = field(default_factory=dict)  # Par√°metros adicionales
    confianza: float = 1.0           # Factor de certeza
    explicacion: str = ""            # Justificaci√≥n de la acci√≥n
    
    def __str__(self) -> str:
        return f"{self.tipo.value}({self.predicado}, {self.valor})"


@dataclass
class ReglaProduccionAcademica:
    """
    REGLA DE PRODUCCI√ìN ACAD√âMICA COMPLETA
    
    FUNDAMENTO TE√ìRICO (Clase 3):
    "reglas de producci√≥n del tipo 'SI (condici√≥n) ENTONCES (acci√≥n)'"
    
    COMPONENTES ACAD√âMICOS:
    1. Identificador √∫nico para referencia y explicaci√≥n
    2. Lista de condiciones (parte SI)  
    3. Lista de acciones (parte ENTONCES)
    4. Metadatos para conflict resolution
    5. Documentaci√≥n para explicaci√≥n
    
    ARQUITECTURA: Modular, explicable, mantenible
    """
    id: str                           # Identificador √∫nico de la regla
    nombre: str                       # Nombre descriptivo
    condiciones: List[CondicionRegla] # Parte SI de la regla
    acciones: List[AccionRegla]       # Parte ENTONCES de la regla
    
    # METADATOS PARA CONFLICT RESOLUTION
    prioridad: float = 0.0           # Prioridad expl√≠cita
    especificidad: Optional[int] = None  # Se calcula autom√°ticamente
    complejidad: Optional[int] = None    # Se calcula autom√°ticamente
    
    # DOCUMENTACI√ìN ACAD√âMICA
    descripcion: str = ""            # Descripci√≥n del prop√≥sito
    dominio: str = ""               # √Årea de conocimiento
    fuente_conocimiento: str = ""    # Fuente del conocimiento (ej: "experto bot√°nico")
    ejemplos: List[str] = field(default_factory=list)  # Ejemplos de uso
    
    # CONTROL DE EJECUCI√ìN
    activa: bool = True              # Si la regla est√° activa
    version: str = "1.0"            # Versi√≥n de la regla
    
    def __post_init__(self):
        """C√ÅLCULO AUTOM√ÅTICO DE METADATOS"""
        if self.especificidad is None:
            self.especificidad = len(self.condiciones)
        
        if self.complejidad is None:
            # Complejidad basada en n√∫mero de condiciones y acciones
            self.complejidad = len(self.condiciones) + len(self.acciones)
    
    def obtener_variables(self) -> List[str]:
        """OBTENER VARIABLES UTILIZADAS EN LA REGLA"""
        variables = []
        for condicion in self.condiciones:
            if condicion.variable:
                variables.append(condicion.variable)
        return list(set(variables))
    
    def generar_explicacion_natural(self) -> str:
        """
        GENERAR EXPLICACI√ìN EN LENGUAJE NATURAL
        
        FUNDAMENTO: "capacidades de explicaci√≥n y su semejanza con el 
        proceso cognitivo humano"
        """
        condiciones_texto = []
        for cond in self.condiciones:
            if cond.explicacion:
                condiciones_texto.append(cond.explicacion)
            else:
                condiciones_texto.append(f"{cond.predicado} {cond.operador.value} {cond.valor}")
        
        acciones_texto = []
        for accion in self.acciones:
            if accion.explicacion:
                acciones_texto.append(accion.explicacion)
            else:
                acciones_texto.append(f"{accion.tipo.value} {accion.predicado}")
        
        return f"SI {' Y '.join(condiciones_texto)}, ENTONCES {', '.join(acciones_texto)}"
    
    def validar_sintaxis(self) -> List[str]:
        """VALIDAR SINTAXIS DE LA REGLA"""
        errores = []
        
        if not self.id or not self.id.strip():
            errores.append("ID de regla requerido")
        
        if not self.condiciones:
            errores.append("Al menos una condici√≥n requerida")
        
        if not self.acciones:
            errores.append("Al menos una acci√≥n requerida")
        
        # Validar condiciones
        for i, cond in enumerate(self.condiciones):
            if not cond.predicado:
                errores.append(f"Condici√≥n {i+1}: predicado requerido")
            if cond.peso <= 0:
                errores.append(f"Condici√≥n {i+1}: peso debe ser positivo")
        
        # Validar acciones
        for i, accion in enumerate(self.acciones):
            if not accion.predicado:
                errores.append(f"Acci√≥n {i+1}: predicado requerido")
            if accion.confianza < 0 or accion.confianza > 1:
                errores.append(f"Acci√≥n {i+1}: confianza debe estar entre 0 y 1")
        
        return errores
    
    def __str__(self) -> str:
        """REPRESENTACI√ìN TEXTUAL DE LA REGLA"""
        return f"Regla[{self.id}]: {self.generar_explicacion_natural()}"


# ===================================================================
# EJEMPLOS ACAD√âMICOS DE SINTAXIS
# ===================================================================

def crear_ejemplos_sintaxis_academica():
    """
    EJEMPLOS DE SINTAXIS DE REGLAS ACAD√âMICAS
    
    Demuestran c√≥mo representar conocimiento bot√°nico real en forma
    de reglas de producci√≥n acad√©micas.
    """
    ejemplos = []
    
    # EJEMPLO 1: Regla de compatibilidad de ubicaci√≥n
    ejemplos.append(ReglaProduccionAcademica(
        id="R001_COMPATIBILIDAD_UBICACION",
        nombre="Compatibilidad de Ubicaci√≥n Interior",
        descripcion="Determina si una planta es compatible con ubicaci√≥n interior",
        dominio="Bot√°nica - Condiciones Ambientales",
        fuente_conocimiento="Manual de Plantas de Interior - Tierra del Fuego",
        
        condiciones=[
            CondicionRegla(
                predicado="ubicacion_usuario",
                operador=OperadorCondicion.IGUAL,
                valor="interior",
                explicacion="El usuario vive en interior"
            ),
            CondicionRegla(
                predicado="planta_tipo_ubicacion",
                operador=OperadorCondicion.EN,
                valor=["interior", "interior_exterior"],
                variable="planta_actual",
                explicacion="La planta tolera condiciones de interior"
            )
        ],
        
        acciones=[
            AccionRegla(
                tipo=TipoAccion.ASSERT,
                predicado="ubicacion_compatible",
                valor=True,
                confianza=0.9,
                explicacion="La planta es compatible con la ubicaci√≥n del usuario"
            )
        ],
        
        prioridad=5.0,
        ejemplos=["Sansevieria en departamento", "Pothos en oficina"]
    ))
    
    # EJEMPLO 2: Regla de an√°lisis de condiciones TDF
    ejemplos.append(ReglaProduccionAcademica(
        id="R002_ANALISIS_CONDICIONES_TDF",
        nombre="An√°lisis de Condiciones Espec√≠ficas de Tierra del Fuego",
        descripcion="Eval√∫a factores ambientales √∫nicos de TDF",
        dominio="Bot√°nica Regional - Tierra del Fuego",
        fuente_conocimiento="INTA - Instituto Nacional de Tecnolog√≠a Agropecuaria",
        
        condiciones=[
            CondicionRegla(
                predicado="ubicacion_usuario",
                operador=OperadorCondicion.IGUAL,
                valor="interior",
                explicacion="Usuario en ambiente interior"
            ),
            CondicionRegla(
                predicado="calefaccion_nivel",
                operador=OperadorCondicion.IGUAL,
                valor="alta",
                explicacion="Calefacci√≥n intensa en invierno TDF"
            ),
            CondicionRegla(
                predicado="humedad_estimada",
                operador=OperadorCondicion.MENOR,
                valor=40,
                explicacion="Humedad baja por calefacci√≥n"
            )
        ],
        
        acciones=[
            AccionRegla(
                tipo=TipoAccion.ASSERT,
                predicado="ambiente_seco_tdf",
                valor=True,
                confianza=0.85,
                explicacion="Ambiente interior seco t√≠pico de TDF en invierno"
            ),
            AccionRegla(
                tipo=TipoAccion.ASSERT,
                predicado="necesita_plantas_resistentes_sequedad",
                valor=True,
                confianza=0.8,
                explicacion="Se requieren plantas resistentes a sequedad"
            )
        ],
        
        prioridad=7.0,
        ejemplos=["Invierno en Ushuaia", "Calefacci√≥n a le√±a en R√≠o Grande"]
    ))
    
    # EJEMPLO 3: Regla de recomendaci√≥n final con m√∫ltiples factores
    ejemplos.append(ReglaProduccionAcademica(
        id="R003_RECOMENDACION_MULTIFACTOR",
        nombre="Recomendaci√≥n Basada en M√∫ltiples Factores",
        descripcion="Combina m√∫ltiples factores para recomendaci√≥n final",
        dominio="Sistema Experto - Inferencia Final",
        fuente_conocimiento="S√≠ntesis de conocimiento experto",
        
        condiciones=[
            CondicionRegla(
                predicado="ubicacion_compatible",
                operador=OperadorCondicion.IGUAL,
                valor=True,
                peso=2.0,
                explicacion="Ubicaci√≥n es compatible"
            ),
            CondicionRegla(
                predicado="iluminacion_suficiente",
                operador=OperadorCondicion.IGUAL,
                valor=True,
                peso=1.5,
                explicacion="Iluminaci√≥n es adecuada"
            ),
            CondicionRegla(
                predicado="mantenimiento_factible",
                operador=OperadorCondicion.IGUAL,
                valor=True,
                peso=1.0,
                explicacion="Mantenimiento est√° al alcance del usuario"
            ),
            CondicionRegla(
                predicado="seguro_mascotas",
                operador=OperadorCondicion.IGUAL,
                valor=True,
                peso=2.0,
                explicacion="Planta es segura para mascotas (si las hay)"
            )
        ],
        
        acciones=[
            AccionRegla(
                tipo=TipoAccion.RECOMMEND,
                predicado="planta_recomendada",
                valor="$planta_actual",
                confianza=0.92,
                explicacion="Planta altamente recomendada basada en todos los factores"
            ),
            AccionRegla(
                tipo=TipoAccion.CONCLUDE,
                predicado="nivel_recomendacion",
                valor="alto",
                confianza=0.9,
                explicacion="Nivel de recomendaci√≥n alto"
            )
        ],
        
        prioridad=10.0,
        ejemplos=["Sansevieria para principiantes", "Pothos para oficinas"]
    ))
    
    return ejemplos


def validar_sintaxis_academica():
    """
    VALIDACI√ìN DE SINTAXIS ACAD√âMICA
    
    Verifica que los ejemplos cumplan con todos los criterios acad√©micos.
    """
    print("üéì VALIDACI√ìN DE SINTAXIS ACAD√âMICA")
    print("="*50)
    
    ejemplos = crear_ejemplos_sintaxis_academica()
    
    for i, regla in enumerate(ejemplos, 1):
        print(f"\nüìã REGLA {i}: {regla.nombre}")
        print("-" * 40)
        
        # Validar sintaxis
        errores = regla.validar_sintaxis()
        if errores:
            print(f"‚ùå Errores encontrados: {errores}")
        else:
            print("‚úÖ Sintaxis v√°lida")
        
        # Mostrar estructura
        print(f"üîç Condiciones: {len(regla.condiciones)}")
        print(f"‚ö° Acciones: {len(regla.acciones)}")
        print(f"üìä Especificidad: {regla.especificidad}")
        print(f"‚öñÔ∏è  Prioridad: {regla.prioridad}")
        
        # Mostrar explicaci√≥n natural
        print(f"üí¨ Explicaci√≥n: {regla.generar_explicacion_natural()}")
        
        # Mostrar variables
        variables = regla.obtener_variables()
        if variables:
            print(f"üîó Variables: {variables}")
    
    print("\n‚úÖ VALIDACI√ìN DE SINTAXIS ACAD√âMICA COMPLETADA")
    print("üìö Sintaxis cumple con fundamentos de Clase 3")
    print("üèõÔ∏è Compatible con sistemas MYCIN/DENDRAL")


# ===================================================================
# DEMOSTRACI√ìN DE SINTAXIS ACAD√âMICA
# ===================================================================

if __name__ == "__main__":
    print("üéì DEMOSTRACI√ìN DE SINTAXIS DE REGLAS ACAD√âMICAS")
    print("="*60)
    print("üìö FUNDAMENTO: Clase 3 - Sistemas de Producci√≥n")
    print("üèõÔ∏è REFERENCIA: Post, Markov, Rete")
    print("‚ö° CARACTER√çSTICAS: Modular, explicable, mantenible")
    print()
    
    # Ejecutar validaci√≥n
    validar_sintaxis_academica()
    
    print("\nüéØ PR√ìXIMO PASO: Implementar parser de reglas")
    print("üìù ESTADO: Sintaxis acad√©mica dise√±ada y validada")